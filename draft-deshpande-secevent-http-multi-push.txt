



Security Events                                             A. Deshpande
Internet-Draft                                                A. Parecki
Intended status: Standards Track                                    Okta
Expires: 8 March 2025                                   4 September 2024


    Multi-Push-Based Security Event Token (SET) Delivery Using HTTP
            draft-deshpande-secevent-http-multi-push-latest

Abstract

   This specification defines how multiple Security Event Tokens (SETs)
   can be delivered to an intended recipient using HTTP POST over TLS.
   The SETs are transmitted in the body of an HTTP POST request to an
   endpoint operated by the recipient, and the recipient indicates
   successful or failed transmission via the HTTP response.

About This Document

   This note is to be removed before publishing as an RFC.

   The latest revision of this draft can be found at
   https://aaronpk.github.io/draft-deshpande-secevent-http-multi-push/
   draft-deshpande-secevent-http-multi-push.html.  Status information
   for this document may be found at https://datatracker.ietf.org/doc/
   draft-deshpande-secevent-http-multi-push/.

   Discussion of this document takes place on the Security Events
   Working Group mailing list (mailto:id-event@ietf.org), which is
   archived at https://mailarchive.ietf.org/arch/browse/id-event/.
   Subscribe at https://www.ietf.org/mailman/listinfo/id-event/.

   Source for this draft and an issue tracker can be found at
   https://github.com/aaronpk/draft-deshpande-secevent-http-multi-push.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 8 March 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
   2.  Multi-Push Endpoint
     2.1.  Transmitting SETs
     2.2.  Response Communication
       2.2.1.  Success Response
       2.2.2.  Error Response
   3.  Conventions and Definitions
   4.  Security Considerations
   5.  IANA Considerations
   6.  Normative References
   Acknowledgments
   Authors' Addresses

1.  Introduction

   This specification defines a mechanism by which a transmitter of a
   Security Event Token (SET) [RFC8417] can deliver multiple SETs to an
   intended SET Recipient via HTTP POST [RFC7231] over TLS in a single
   POST call.  [RFC8935] focuses on the delivery of the single SET to
   the receiver.  This specification builds onto [RFC8935] to transmit
   multiple SETs to the receiver in a single POST call.

   Multi-push SET delivery is intended to help in following scenarios: -
   The transmitter of the SET has multiple outstanding SETs to be
   communicated to the receiver - The transmitter wants to reduce the
   number of outbound calls to the same receiver to optimize
   performance, avoid being ratelimited when number of SETs to be
   communicated is high - The receiver wants to optimize processing
   multiple SETs

   Multi-push specification will handle all the usecases and scenarios
   for the [RFC8935] and make it more extensible to support multiple
   SETs per one outbound POST call.

   Similar to [RFC8935] this specification makes mechanism for
   exchanging configuration metadata such as endpoint URLs,
   cryptographic keys, and possible implementation constraints such as
   buffer size limitations between the transmitter and recipient is out
   of scope.

2.  Multi-Push Endpoint

   Each Receiver that supports this specification MUST support a "multi-
   push" endpoint.  This endpoint MUST be capable of serving HTTP
   [RFC9110] requests.  This endpoint MUST be TLS [RFC8446] enabled and
   MUST reject any communication not using TLS.

   The existing PUSH endpoint could also be extended to support
   accepting multiple SETs

2.1.  Transmitting SETs

   A Transmitter may initiate communication with the receiver in order
   to: - Send SETs to the Receiver - Recive acknowledgement of the SETs
   in response

   The body of this request is of the content type "application/json".
   It MAY contains the following fields:

   sets OPTIONAL.  A JSON object containing key-value pairs in which the
   key of a field is a string that contains the jti value of the SET
   that is specified in the value of the field.  This field MAY be
   omitted to indicate that no SETs are being delivered by the initiator
   in this communication.  The Transmitter SHOULD limit 20 SETs in the
   sets.

   moreAvailable A JSON boolean value that indicates if more
   unacknowledged SETs are available to be returned.  This member MAY be
   omitted, with the meaning being the same as including it with the
   boolean value false.

   The following is a non-normative example of a Communication Object

     {
       "sets": {
         "4d3559ec67504aaba65d40b0363faad8":
         "eyJhbGciOiJub25lIn0.
         eyJqdGkiOiI0ZDM1NTllYzY3NTA0YWFiYTY1ZDQwYjAzNjNmYWFkOCIsImlhdC
         I6MTQ1ODQ5NjQwNCwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
         YXVkIjpbImh0dHBzOi8vc2NpbS5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
         ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL0Zl
         ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwiZXZlbnRzIjp7InVybj
         ppZXRmOnBhcmFtczpzY2ltOmV2ZW50OmNyZWF0ZSI6eyJyZWYiOiJodHRwczov
         L3NjaW0uZXhhbXBsZS5jb20vVXNlcnMvNDRmNjE0MmRmOTZiZDZhYjYxZTc1Mj
         FkOSIsImF0dHJpYnV0ZXMiOlsiaWQiLCJuYW1lIiwidXNlck5hbWUiLCJwYXNz
         d29yZCIsImVtYWlscyJdfX19.",
         "3d0c3cf797584bd193bd0fb1bd4e7d30":
         "eyJhbGciOiJub25lIn0.
         eyJqdGkiOiIzZDBjM2NmNzk3NTg0YmQxOTNiZDBmYjFiZDRlN2QzMCIsImlhdC
         I6MTQ1ODQ5NjAyNSwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
         YXVkIjpbImh0dHBzOi8vamh1Yi5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
         ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9qaHViLmV4YW1wbGUuY29tL0Zl
         ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwic3ViIjoiaHR0cHM6Ly
         9zY2ltLmV4YW1wbGUuY29tL1VzZXJzLzQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIx
         ZDkiLCJldmVudHMiOnsidXJuOmlldGY6cGFyYW1zOnNjaW06ZXZlbnQ6cGFzc3
         dvcmRSZXNldCI6eyJpZCI6IjQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIxZDkifSwi
         aHR0cHM6Ly9leGFtcGxlLmNvbS9zY2ltL2V2ZW50L3Bhc3N3b3JkUmVzZXRFeH
         QiOnsicmVzZXRBdHRlbXB0cyI6NX19fQ."
       }
     }

     Figure 1: Example of SET Transmission

   In the above example, the Transmitter is sending 2 SETs to the
   Receiver.

     {
       "sets": {
         "4d3559ec67504aaba65d40b0363faad8":
         "eyJhbGciOiJub25lIn0.
         eyJqdGkiOiI0ZDM1NTllYzY3NTA0YWFiYTY1ZDQwYjAzNjNmYWFkOCIsImlhdC
         I6MTQ1ODQ5NjQwNCwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
         YXVkIjpbImh0dHBzOi8vc2NpbS5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
         ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tL0Zl
         ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwiZXZlbnRzIjp7InVybj
         ppZXRmOnBhcmFtczpzY2ltOmV2ZW50OmNyZWF0ZSI6eyJyZWYiOiJodHRwczov
         L3NjaW0uZXhhbXBsZS5jb20vVXNlcnMvNDRmNjE0MmRmOTZiZDZhYjYxZTc1Mj
         FkOSIsImF0dHJpYnV0ZXMiOlsiaWQiLCJuYW1lIiwidXNlck5hbWUiLCJwYXNz
         d29yZCIsImVtYWlscyJdfX19.",
         "3d0c3cf797584bd193bd0fb1bd4e7d30":
         "eyJhbGciOiJub25lIn0.
         eyJqdGkiOiIzZDBjM2NmNzk3NTg0YmQxOTNiZDBmYjFiZDRlN2QzMCIsImlhdC
         I6MTQ1ODQ5NjAyNSwiaXNzIjoiaHR0cHM6Ly9zY2ltLmV4YW1wbGUuY29tIiwi
         YXVkIjpbImh0dHBzOi8vamh1Yi5leGFtcGxlLmNvbS9GZWVkcy85OGQ1MjQ2MW
         ZhNWJiYzg3OTU5M2I3NzU0IiwiaHR0cHM6Ly9qaHViLmV4YW1wbGUuY29tL0Zl
         ZWRzLzVkNzYwNDUxNmIxZDA4NjQxZDc2NzZlZTciXSwic3ViIjoiaHR0cHM6Ly
         9zY2ltLmV4YW1wbGUuY29tL1VzZXJzLzQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIx
         ZDkiLCJldmVudHMiOnsidXJuOmlldGY6cGFyYW1zOnNjaW06ZXZlbnQ6cGFzc3
         dvcmRSZXNldCI6eyJpZCI6IjQ0ZjYxNDJkZjk2YmQ2YWI2MWU3NTIxZDkifSwi
         aHR0cHM6Ly9leGFtcGxlLmNvbS9zY2ltL2V2ZW50L3Bhc3N3b3JkUmVzZXRFeH
         QiOnsicmVzZXRBdHRlbXB0cyI6NX19fQ."
       },
       "moreAvailable": 10

     }

     Figure 2: Example of SET Transmission with "moreAvailable"

   In the above example, the Transmitter is sending 2 SETs to the
   Receiver.  The Tranmitter is also communicating to the reciver the
   outstanding SETs to be transmitted.

     {
       "sets": {},
     }

     Figure 3: Example of empty SET transmission

   In the above example, the Transmitter is sending zero SETs to the
   Receiver.  This placeholder/empty request provides the Receiver to
   respond back with ack/err for previously transmitted SETs

2.2.  Response Communication

   A Receiver MUST repond to the communication by sending an HTTP
   response.  The body of this response is of the content type
   "application/json".  It contains MAY contain following fields:

   ack OPTIONAL.  An array of strings, in which each string is the jti
   value of a previously received SET that is acknowledged in this
   object.  This array MAY be empty or this field MAY be omitted to
   indicate that no previously received SETs are being acknowledged in
   this communication.

   setErrs OPTIONAL.  A JSON object containing key-value pairs in which
   the key of a field is a string that contains the jti value of a
   previously received SET that the sender of the communication object
   was unable to process.  The value of the field is a JSON object that
   has the following fields:

   err OPTIONAL.  The short reason why the specified SET failed to be
   processed.

   description OPTIONAL.  An explanation of why the SET failed to be
   processed

2.2.1.  Success Response

   If the Receiver is successful in processing the request, it MUST
   return the HTTP status code 200 (OK).  The response MUST have the
   content-type "application/json" and the response MUST include a
   Communication Object Section X.

     HTTP/1.1 200 OK
     Content-type: application/json

     {
       "ack": [
         "3d0c3cf797584bd193bd0fb1bd4e7d30"
       ]
     }

     Figure 3: Example of SET Transmission response with ack

   In the above example, the Receiver acknowledges one of the SETs it
   previously received.  There are no errors reported by the Receiver.

     HTTP/1.1 200 OK
     Content-type: application/json

     {
        "ack": [
         "f52901c4-3996-11ef-9454-0242ac120002",
         "0636e274-3997-11ef-9454-0242ac120002",
         "d563c724-79a0-4ff0-ba41-657fa5e2cb11"
        ],
        "setErrs": {
         "5c436b19-0958-4367-b408-2dd542606d3b" : {
           "err": "invalid subject",
           "description": "subject format not supported"
         }
        }
     }

     Figure 4: Example of SET Transmission response, with ack and errors

   In the above example, the Receiver acknowledges three of the SETs it
   previously received.  There are errors reported by the Receiver for
   acklowledging one SET.

2.2.2.  Error Response

   The receiver MUST respond with an error response if it is unable to
   process the request.  The error response MUST include the appropriate
   error code as described in Section 2.4 of DeliveryPush [RFC8935].

3.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

4.  Security Considerations

   TODO Security

5.  IANA Considerations

   This document has no IANA actions.

6.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC7231]  Fielding, R., Ed. and J. Reschke, Ed., "Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content", RFC 7231,
              DOI 10.17487/RFC7231, June 2014,
              <https://www.rfc-editor.org/rfc/rfc7231>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC8417]  Hunt, P., Ed., Jones, M., Denniss, W., and M. Ansari,
              "Security Event Token (SET)", RFC 8417,
              DOI 10.17487/RFC8417, July 2018,
              <https://www.rfc-editor.org/rfc/rfc8417>.

   [RFC8446]  Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", RFC 8446, DOI 10.17487/RFC8446, August 2018,
              <https://www.rfc-editor.org/rfc/rfc8446>.

   [RFC8935]  Backman, A., Ed., Jones, M., Ed., Scurtescu, M., Ansari,
              M., and A. Nadalin, "Push-Based Security Event Token (SET)
              Delivery Using HTTP", RFC 8935, DOI 10.17487/RFC8935,
              November 2020, <https://www.rfc-editor.org/rfc/rfc8935>.

   [RFC9110]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., "HTTP Semantics", STD 97, RFC 9110,
              DOI 10.17487/RFC9110, June 2022,
              <https://www.rfc-editor.org/rfc/rfc9110>.

Acknowledgments

   TODO acknowledge.

Authors' Addresses

   Apoorva Deshpande
   Okta
   Email: apoorva.deshpande@okta.com


   Aaron Parecki
   Okta
   Email: aaron@parecki.com
